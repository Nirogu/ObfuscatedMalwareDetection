<h1 id="Obfuscated-Malware-Detection">Obfuscated Malware Detection</h1>
<p>Code associated to the paper: Towards Obfuscated Malware Detection Using Deep Learning Models and Transfer Learning</p>
<h1 id="QUICK-START-GUIDE">QUICK START GUIDE</h1>
<p>Before executing this project you have to consider the data flow of the solution so you may decide what component(s) you desire to execute. In the data flow shown below we may identify different components which have the following functionality:</p>
<ol>
<li>Entropy tester : This classifier detect if a sample is or not obfuscated</li>
<li>Image Transformer : This module convert a sample to image</li>
<li>Not Encoded Classifier : This classfier is able to detect if a non encoded sample is Goodware or Malware</li>
<li>Shikata Ga Nai / XOR Classfiier : This classifier is able to detect if a Shikata Ga Nai / XOR encoded sample is is Goodware or Malware</li>
</ol>
<p>You may decide to test each one of the modules that compose the flow or go directly to the deployed web application version.</p>

![Flow](images/flow.png)

<p>Entropy Tester</p>
<p>The Python code to identify whether a binary file has been obfuscated (XOR/Shikata Ga Nai) can be found in the notebook entropy_tester/entropy_tester.ipynb. In the cell called Create and write entropy data, the entropies for every file in the folders indicated by the user (in this case, the folders containing the samples from the previous section) are extracted and saved in a file named entropies.csv, which can be found in the entropy_tester folder. Then, the cell called Read entropy data reads the CSV file. The remaining cells in the notebook test the performance of several machine learning algorithms when identifying obfuscated binary files based on their entropy.</p>

## Obtaining the samples

### Goodware


The goodware samples used for this project were obtained using 2 different sources.

The first one was using the service [PortableApps](https://portableapps.com/) provides. We manually downloaded all the software this solution offers and moved all the files to a folder named "Goodware".

On parallel, for the second source, we installed a 32 bit version of Windows 10 and copied all files from the `System32` folder to the same "Goodware" folder.

Then the preprocessing phase started. In the preprocessing, we employed the `file` command from an Ubuntu installation to remove all files that did not include the strings `PE32 executable`and `for MS Windows`. This process can be seen on Python script `dataset_creation_scripts/cleanType.py`. This left us with a total of 457 sample files obtained from PortableApps and 15171 sample files obtained from a Windows installation, for a total of 15628 goodware samples.

#### Malware

To obtain the malware samples we contacted the staff team of [VirusShare](https://virusshare.com/) and requested acess to their malware repository. Once the access was granted, we donwnloaded the torrent \#144 (VirusShare_00144.zip, 87.44 GB) which contained PE for Microsoft Windows and repeated the process of cleaning by type using the Python script `dataset_creation_scripts/cleanType.py` and then we randomy chose a similar amount of goodware binaries (15821) in order to compose a balanced dataset, as can be seen in the Python script `dataset_creation_scripts/cleanAmount.py`.



## Detecting obfuscation

The Python code to identify whether a binary file has been obfuscated (XOR/Shikata Ga Nai) can be found in the notebook `entropy_tester/entropy_tester.ipynb`. In the cell called *Create and write entropy data*, the entropies for every file in the folders indicated by the user (in this case, the folders containing the samples from the previous section) are extracted and saved in a file named `entropies.csv`, which can be found in the `entropy_tester` folder. Then, the cell called *Read entropy data* reads the CSV file. The remaining cells in the notebook test the performance of several machine learning algorithms when identifying obfuscated binary files based on their entropy.


## Obtaining the images

The script `binary2image.py` transforms executable files into grayscale images, as described in Section 3.3.2 "Image Transformer" of the paper. The script can be used in the following way: `python binary2image.py input_folder output_folder`
Where `input_folder` contains the binary files and `output_folder` will contain the resulting images.


## Detecting malware

The notebook `cnn_tester.ipynb` reads the images from the previous step and tests the performance of four different CNN architectures when identifying malware: ResNet18, ResNet34, EfficientNetB3, and EfficientNetV2. The notebook can be executed completely just by setting the value of the variable `path` to the images folder which will be processed.


